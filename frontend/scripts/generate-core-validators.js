#!/usr/bin/env node

/**
 * Generate Zod validators from core schemas endpoint
 * This fetches the core Pydantic schemas from the backend and generates TypeScript Zod validators
 */

const fs = require('fs');
const path = require('path');

// Configuration
const BACKEND_URL = process.env.BACKEND_URL || 'http://localhost:8000';
const SCHEMAS_ENDPOINT = '/api/v1/schemas/core';
const OUTPUT_JSON = path.join(__dirname, '../src/core-schemas.json');
const OUTPUT_TS = path.join(__dirname, '../src/core-schemas.ts');

async function fetchCoreSchemas() {
  try {
    console.log(`Fetching core schemas from ${BACKEND_URL}${SCHEMAS_ENDPOINT}...`);
    const response = await fetch(`${BACKEND_URL}${SCHEMAS_ENDPOINT}`);
    
    if (!response.ok) {
      throw new Error(`Failed to fetch schemas: ${response.status} ${response.statusText}`);
    }
    
    const schemas = await response.json();
    return schemas;
  } catch (error) {
    console.error('Error fetching schemas:', error);
    throw error;
  }
}

function jsonSchemaToZod(schema, schemaName) {
  const props = schema.properties || {};
  const required = schema.required || [];
  
  const fields = [];
  
  for (const [key, value] of Object.entries(props)) {
    let fieldSchema = '';
    
    // Handle different types
    if (value.type === 'string') {
      if (value.enum) {
        fieldSchema = `z.enum([${value.enum.map(e => `"${e}"`).join(', ')}])`;
      } else {
        fieldSchema = 'z.string()';
      }
    } else if (value.type === 'number' || value.type === 'integer') {
      fieldSchema = 'z.number()';
    } else if (value.type === 'boolean') {
      fieldSchema = 'z.boolean()';
    } else if (value.type === 'array') {
      if (value.items) {
        if (value.items.$ref) {
          const refName = value.items.$ref.split('/').pop();
          fieldSchema = `z.array(${refName}Schema)`;
        } else if (value.items.type === 'string') {
          fieldSchema = 'z.array(z.string())';
        } else {
          fieldSchema = 'z.array(z.any())';
        }
      } else {
        fieldSchema = 'z.array(z.any())';
      }
    } else if (value.$ref) {
      const refName = value.$ref.split('/').pop();
      fieldSchema = `${refName}Schema`;
    } else if (value.anyOf) {
      // Handle nullable fields
      const hasNull = value.anyOf.some(t => t.type === 'null');
      const nonNull = value.anyOf.find(t => t.type !== 'null');
      if (hasNull && nonNull) {
        if (nonNull.type === 'string') {
          fieldSchema = 'z.string().nullable()';
        } else {
          fieldSchema = 'z.any().nullable()';
        }
      } else {
        fieldSchema = 'z.any()';
      }
    } else {
      fieldSchema = 'z.any()';
    }
    
    // Add optional if not required
    if (!required.includes(key)) {
      fieldSchema += '.optional()';
    }
    
    // Add description if available
    if (value.description) {
      fieldSchema += `.describe("${value.description.replace(/"/g, '\\"')}")`;
    }
    
    fields.push(`  ${key}: ${fieldSchema}`);
  }
  
  return `z.object({\n${fields.join(',\n')}\n})`;
}

function generateZodValidators(schemas) {
  const validators = [];
  const generatedSchemas = new Set(); // Track already generated schemas
  
  // Generate header
  validators.push(`// Auto-generated Zod validators from core schemas
// DO NOT EDIT - Generated by scripts/generate-core-validators.js
import { z } from 'zod';

`);

  // Process each main schema (not $defs)
  const mainSchemas = Object.entries(schemas).filter(([key]) => key !== '$defs');
  
  // First generate schemas that might be referenced
  for (const [schemaName, schemaDefinition] of mainSchemas) {
    if (schemaDefinition.$defs) {
      // Process embedded definitions first
      for (const [defName, defSchema] of Object.entries(schemaDefinition.$defs)) {
        if (!generatedSchemas.has(defName)) { // Only generate if not already done
          try {
            const zodSchema = jsonSchemaToZod(defSchema, defName);
            validators.push(`// ${defName} Schema
export const ${defName}Schema = ${zodSchema};
export type ${defName} = z.infer<typeof ${defName}Schema>;

`);
            generatedSchemas.add(defName); // Mark as generated
          } catch (error) {
            console.warn(`Warning: Could not generate validator for ${defName}:`, error.message);
          }
        }
      }
    }
  }
  
  // Then generate main schemas
  for (const [schemaName, schemaDefinition] of mainSchemas) {
    if (!generatedSchemas.has(schemaName)) { // Only generate if not already done
      try {
        const zodSchema = jsonSchemaToZod(schemaDefinition, schemaName);
        validators.push(`// ${schemaName} Schema
export const ${schemaName}Schema = ${zodSchema};
export type ${schemaName} = z.infer<typeof ${schemaName}Schema>;

`);
        generatedSchemas.add(schemaName); // Mark as generated
      } catch (error) {
        console.warn(`Warning: Could not generate validator for ${schemaName}:`, error.message);
      }
    }
  }
  
  // Add helper functions
  validators.push(`// Helper functions for validation
export function validateValidationResponse(data: unknown) {
  return ValidationResponseSchema.parse(data);
}

export function validatePostEditResponse(data: unknown) {
  // Since we don't have PostEditResponse schema yet, return data as-is
  // TODO: Add PostEditResponseSchema when available
  return data;
}

export function validateAnalysisLogEntry(data: unknown) {
  // Since we don't have AnalysisLogEntry schema yet, return data as-is
  // TODO: Add AnalysisLogEntrySchema when available
  return data;
}

// Safe validation functions that return null on error
export function safeValidateValidationResponse(data: unknown) {
  try {
    return ValidationResponseSchema.parse(data);
  } catch {
    return null;
  }
}
`);
  
  return validators.join('');
}

async function main() {
  try {
    // Step 1: Fetch schemas
    const schemas = await fetchCoreSchemas();
    
    // Step 2: Save JSON schemas
    console.log(`Saving JSON schemas to ${OUTPUT_JSON}...`);
    fs.writeFileSync(OUTPUT_JSON, JSON.stringify(schemas, null, 2));
    
    // Step 3: Generate Zod validators
    console.log(`Generating Zod validators at ${OUTPUT_TS}...`);
    const validatorsCode = generateZodValidators(schemas);
    fs.writeFileSync(OUTPUT_TS, validatorsCode);
    
    console.log('✅ Successfully generated core validators!');
    console.log(`  - JSON schemas: ${OUTPUT_JSON}`);
    console.log(`  - Zod validators: ${OUTPUT_TS}`);
    
  } catch (error) {
    console.error('❌ Failed to generate validators:', error);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  main();
}

module.exports = { fetchCoreSchemas, generateZodValidators };